
# Домашнее задание №7


* **Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.**  
![Альт-текст](Images/HW7/01.png)  
![Альт-текст](Images/HW7/02.png)  
![Альт-текст](Images/HW7/03.png)  
![Альт-текст](Images/HW7/04.png)  
![Альт-текст](Images/HW7/05.png)  
![Альт-текст](Images/HW7/06.png)  
_В принципе по скринам всё должно быть понятно. Делалось в двух сессиях. PID первой = 1285, PID второй 1359._  

* **Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.**  
![Альт-текст](Images/HW7/07.png)  
_Удаление, создание и заполнение таблицы accounts_  
![Альт-текст](Images/HW7/08.png)  
_Построим представление над pg_locks. Оно содержит только то что нужно для нашего эксперимента._  

_Выдержка из книги (PostgreSQL 16 изнутри), только вчитываясь в эти строки я начал что-то понимать:_  
_Когда транзакция собирается изменить строку, она выполняет следующую последовательность действий:_  
_1) если поле xmax и информационные биты версии строки указывают на то, что строка заблокирована в несовместимом режиме, захватывает исключительную тяжелую блокировку изменяемой версии строки;  
2) при необходимости дожидается освобождения несовместимых блокировок, запрашивая блокировку номера транзакции xmax (или нескольких транзакций, если xmax — мультитранзакция);  
3) прописывает в версию строки свой номер (в поле xmax) и устанавливает необходимые информационные биты;  
4) освобождает блокировку версии строки, если она захватывалась в п. 1._  

![Альт-текст](Images/HW7/09.png)  
_Транзакция успешно выполняет четыре шага последовательности и теперь удерживает блокировку таблицы._  

![Альт-текст](Images/HW7/10.png)  
_Начинаем вторую транзакцию и пытаемся обновить ту же строку._  

![Альт-текст](Images/HW7/11.png)  
_Вторая транзакция дошла только до второго шага. Поэтому, помимо блокировки таблицы и собственного номера, она добавляет в pg_locks еще две
строки: захваченную на первом шаге блокировку типа tuple и запрошенную на втором шаге блокировку номера первой транзакции._  

![Альт-текст](Images/HW7/12.png)  
_Запуск третьей транзакции._  

![Альт-текст](Images/HW7/13.png)  
_Третья транзакция дойдет только до первого шага. Она попытается захватить блокировку версии строки и остановится уже на этом._  
_К слову четвертая и последующие транзакции, желающие обновить ту же самую строку, ничем не будут отличаться от третьей — все они будут ожидать одну
и ту же блокировку версии строки._  

![Альт-текст](Images/HW7/14.png)  
_Получившуюся очередь можно увидеть таким способом._  

![Альт-текст](Images/HW7/15.png)  
_COMMITим первую транзакцию, вторая просыпается и успешно выполняет третий и четвертый шаги последовательности._  

![Альт-текст](Images/HW7/16.png)  
_В моём эсперименте получаем такую картину. Третья транзакция осуществила захват блокировки версии строки_  
_При этом в книге, по инструкциям которой я следовал, автор пишет, что этого не должно было бы произойти:_  
![Альт-текст](Images/HW7/17.png)  
_Почему произошло такое расхождение действительности с книгой я не понимаю, видимо я что-то сделал не так, ибо книга не может ошибаться :)_  

![Альт-текст](Images/HW7/18.png)  
_COMMITим вторую транзакцию. У третьей транзакции остаются только блокировки её номера и таблицы._  

_COMMIT третью транзакцию - блокировки исчезают._  


* **Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?**
![Альт-текст](Images/HW7/19.png)  
![Альт-текст](Images/HW7/20.png)  
![Альт-текст](Images/HW7/21.png)  
![Альт-текст](Images/HW7/22.png)

* **Сравните tps в синхронном/асинхронном режиме утилитой pgbench. Объясните полученный результат.**  
_Запустил pgbench в синхронном режиме._  
![Альт-текст](Images/HW6/07.png)  

_Переключился в асинхронный режим._  
![Альт-текст](Images/HW6/08.png)  

_Запустил pgbench в асинхронный режиме._  
![Альт-текст](Images/HW6/09.png)  

_В результате видим, что в асинхронном режиме время отклика (latency (3.206 ms -> 0.540 ms)) существенно уменьшилось, а пропускная способность (tps) увеличилась (311.953344 -> 1851.252304)._  
_Плата за это - меньшая надежность. Цитата из книги (PostgreSQL изнутри):
"Асинхронная запись эффективнее синхронной — фиксация изменений не ждет физической записи на диск. Однако надежность уменьшается: в случае сбоя зафиксированные данные могут пропасть, если после
фиксации прошло менее 3 × wal_writer_delay единиц времени (что при настройке по умолчанию составляет 0,6 секунды)."_  


* **Создайте новый кластер с включенной контрольной суммой страниц. Создайте таблицу. Вставьте несколько значений. Выключите кластер. Измените пару байт в таблице. Включите кластер и сделайте выборку из таблицы. Что и почему произошло? как проигнорировать ошибку и продолжить работу?**  
_Создавать новый кластер я не стал. Поменял параметр в текущем кластере._  
![Альт-текст](Images/HW6/10.png)  
![Альт-текст](Images/HW6/11.png)  
![Альт-текст](Images/HW6/12.png)  
_Запустил кластер, создал таблицу и три строки в ней._  
![Альт-текст](Images/HW6/13.png)  
_Снова опустил кластер предварительно записав путь до таблицы в файловой системе._  
![Альт-текст](Images/HW6/14.png)  
_Командой (взятой из той же книги, правда путь мне пришлось немного изменить) внёс изменения в файл._  
![Альт-текст](Images/HW6/15.png)  
_Запустил кластер и пробовал зачитать строки из таблицы, получил ошибку, так как рассчитанная контрольная сумма не соответствует ожидаемой:_  
![Альт-текст](Images/HW6/16.png)  
_Можно проигнорировать данную ошибку таким образом:_  
![Альт-текст](Images/HW6/17.png)  
_Понято дело, что при игнорировании данной ошибки есть риск получить искажённую информацию._


