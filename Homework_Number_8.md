
# Домашнее задание №8


* **Развернуть виртуальную машину любым удобным способом.**  
![Альт-текст](Images/HW8/00.png)  
_Создана ВМ с самыми минимальными ресурсами, что бы минимизировать затраты на её содержание. Посмотрим, что можно выжать из неё в плане производительности PostgreSQL._  
_Сразу хочу сказать, что данная домашняя работа заняла у меня больше времени (в сравнении с предыдущими), так как в предыдущих работах был достаточно чёткий план действий, в этой же работе, я почувствовал, что действую 
 по большей части интуитивно (когда крутил все эти параметры настройки). Возможно дело в том, что я скорее отношу себя к разработчикам, нежели чем к администраторам, хотя по работе заниматься приходится и тем и другим. 
 Результат, конечно есть, но осталось чувство незавершённости и понимание, того что тюнинговать PostgreSQL можно практически бесконечно._  

* **Поставить на неё PostgreSQL 15 любым способом.**  
_На ВМ установлен PostgreSQL 16_  

* **настроить кластер PostgreSQL 15 на максимальную производительность не обращая внимание на возможные проблемы с надежностью в случае аварийной перезагрузки виртуальной машины.**  
![Альт-текст](Images/HW8/01.png)  
![Альт-текст](Images/HW8/02.png)  
_Создал свой конфигурационный файл custom.conf._  
_Прописал в нём параметры близкие, как мне думалось на тот момент, к масимально возможным (часть оставил на рекомендуемом уровне, поэкперименитовароть с ними решил на следующем шаге)._  

* **Нагрузить кластер через утилиту через утилиту pgbench (https://postgrespro.ru/docs/postgrespro/14/pgbench)**
* **написать какого значения tps удалось достичь, показать какие параметры в какие значения устанавливали и почему**  
![Альт-текст](Images/HW8/03.png)
_С такими параметрами имеем 216 tps._  
_Так, подумал я, а давайте-ка теперь последовательно менять каждый из параметров и замерять tps, интересно ведь. Таким образом, для каждого параметра я проводил замер tps при минимальном, среднем и максимальном его значении. И составлял у себя в блокнотике статистику. Делалось по три замера (на некоторых параметрах было и больше трёх), так как tps при каждом новом запуске теста мог колебаться находилось среднее арифметическое згачение tps._
![Альт-текст](Images/HW8/04.png)  
_Часть моих записей, мало информативно, но смысл понятен._  


_Построим представление над pg_locks. Оно содержит только то что нужно для нашего эксперимента._  

_Выдержка из книги (PostgreSQL 16 изнутри), только вчитываясь в эти строки я начал что-то понимать:_  
_Когда транзакция собирается изменить строку, она выполняет следующую последовательность действий:_  
_1) если поле xmax и информационные биты версии строки указывают на то, что строка заблокирована в несовместимом режиме, захватывает исключительную тяжелую блокировку изменяемой версии строки;  
2) при необходимости дожидается освобождения несовместимых блокировок, запрашивая блокировку номера транзакции xmax (или нескольких транзакций, если xmax — мультитранзакция);  
3) прописывает в версию строки свой номер (в поле xmax) и устанавливает необходимые информационные биты;  
4) освобождает блокировку версии строки, если она захватывалась в п. 1._  

![Альт-текст](Images/HW7/09.png)  
_Транзакция успешно выполняет четыре шага последовательности и теперь удерживает блокировку таблицы и блокирует собственный номер._  

![Альт-текст](Images/HW7/10.png)  
_Начинаем вторую транзакцию и пытаемся обновить ту же строку._  

![Альт-текст](Images/HW7/11.png)  
_Вторая транзакция дошла только до второго шага. Поэтому, помимо блокировки таблицы и собственного номера, она добавляет в pg_locks еще две
строки: захваченную на первом шаге блокировку типа tuple и запрошенную на втором шаге блокировку номера первой транзакции._  

![Альт-текст](Images/HW7/12.png)  
_Запуск третьей транзакции._  

![Альт-текст](Images/HW7/13.png)  
_Третья транзакция дойдет только до первого шага. Она попытается захватить блокировку версии строки и остановится уже на этом._  
_К слову четвертая и последующие транзакции, желающие обновить ту же самую строку, ничем не будут отличаться от третьей — все они будут ожидать одну
и ту же блокировку версии строки._  

![Альт-текст](Images/HW7/14.png)  
_Получившуюся очередь можно увидеть таким способом._  

![Альт-текст](Images/HW7/15.png)  
_COMMITим первую транзакцию, вторая просыпается и успешно выполняет третий и четвертый шаги последовательности._  

![Альт-текст](Images/HW7/16.png)  
_В моём эсперименте получаем такую картину. Третья транзакция осуществила захват блокировки версии строки_  
_При этом в книге, по инструкциям которой я следовал, автор пишет, что этого не должно было бы произойти:_  
![Альт-текст](Images/HW7/17.png)  
_Почему произошло такое расхождение действительности с книгой я не понимаю, видимо я что-то сделал не так, ибо книга не может ошибаться :)_  

![Альт-текст](Images/HW7/18.png)  
_COMMITим вторую транзакцию. У третьей транзакции остаются только блокировки её номера и таблицы._  

_COMMIT третью транзакцию - блокировки исчезают._  


* **Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?**  
![Альт-текст](Images/HW7/19.png)  
![Альт-текст](Images/HW7/20.png)  
![Альт-текст](Images/HW7/21.png)  
![Альт-текст](Images/HW7/22.png)
_Как и в первом задании, считаю что скринов достаточно, как ни странно в учебной литературе мне встретились только примеры взаимоблокировки двух транзакций, так что мне пришлось немного поэкспериментировать, что бы вызвать взаимоблокировку трёх транзакций._  

* **Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?**  
_В ходе эксперимента (основу которого я взял из книги) я установил что без where транзакции не должны заблокировать друг друга. Но я не исключаю, что я чего-то мог не учесть._  

_Описание эксперимента:_  

![Альт-текст](Images/HW7/23.png)  
_Создадим таблицу и заполним её данными._  

![Альт-текст](Images/HW7/24.png)  
_Для воспроизведения создадим индекс по столбцу amount, построенный по убыванию суммы_  
_Чтобы успеть увидеть происходящее, напишем замедляющую функцию_  

![Альт-текст](Images/HW7/25.png)  
_Первая команда UPDATE будет обновлять всю таблицу. План выполнения — последовательный просмотр всей таблицы_  

![Альт-текст](Images/HW7/26.png)  
_Во второй сессии запретим использование последовательного сканирования_  

![Альт-текст](Images/HW7/27.png)  
_И проверим план запроса (если условие where есть)  
postgres=# EXPLAIN (costs off)  
UPDATE accounts SET amount = inc_slow(amount)  
WHERE amount > 100.00;  
                       QUERY PLAN  
    ---------------------------------------------  
 Update on accounts  
   ->  Index Scan using accounts_amount_idx on accounts  
         Index Cond: (amount > 100.00)_  
         
_Как видим, будет использоваться индекс и следовательно данный апдейт пойдёт по записям в обратном порядке (так как индекс был создан с параметром DESC, по убыванию)  
Однако если убрать из запроса условие, то видим следующий план запроса:_  

postgres=# EXPLAIN (costs off)  
UPDATE accounts SET amount = inc_slow(amount);  
         QUERY PLAN    
    ---------------------------------------------  
 Update on accounts  
   ->  Seq Scan on accounts  
_То есть в данном случае наш апдейт пойдёт точно так же как и в первой сессии и взаимоблокировки не будет._  

![Альт-текст](Images/HW7/28.png)  
_Скрин возникновения взаимоблокировки в первой сессии, если во второй запустить апдейт с условием (WHERE amount > 100.00;).  
Взаимоблокировка возникает из-за того что апдейту навстречу друг другу._  

![Альт-текст](Images/HW7/29.png)  
_Если же запускать апдейт без условия то всё отрабатывает без взаимоблокировок в обейх сессия, так как апдейты идут "друг за другом", а не навстречу._  

